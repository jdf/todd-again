package main

import (
	"fmt"
	"html/template"
	"log"

	gamepb "github.com/jdf/todd-again/game/proto"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

type generator struct {
	*protogen.GeneratedFile
}

func (g *generator) doTemplate(code string, data interface{}) {
	t := template.Must(template.New("code").Parse(code))
	if err := t.Execute(g, data); err != nil {
		log.Fatalf("failed to execute template: %v", err)
	}
}

func (g *generator) emitFloat32(f *protogen.Field) {
	if !f.Desc.HasDefault() {
		panic("all settings must have a default value")
	}
	defaultValue := float32(f.Desc.Default().Float())

	data := map[string]interface{}{
		"name": f.GoName,
	}

	opts := f.Desc.Options().(*descriptorpb.FieldOptions)
	data["min"] = 0.5 * defaultValue
	if proto.HasExtension(opts, gamepb.E_Min) {
		data["min"] = proto.GetExtension(opts, gamepb.E_Min).(float32)
	}
	data["max"] = 2 * defaultValue
	if proto.HasExtension(opts, gamepb.E_Max) {
		data["max"] = proto.GetExtension(opts, gamepb.E_Max).(float32)
	}
	code := `
	{
		tmpFloat32 = p.Get{{.name}}()
		imgui.SliderFloat("{{.name}}", &tmpFloat32, {{.min}}, {{.max}})
		if p.{{.name}} == nil {
			var f float32
			p.{{.name}} = &f
		}
		*p.{{.name}} = tmpFloat32
	}
`
	g.doTemplate(code, data)
}

func (g *generator) emitFloat64(f *protogen.Field) {
	name := f.GoName
	code := fmt.Sprintf(`
tmpFloat64 = p.Get%s()
imgui.InputFloat("%s", &tmpFloat64)
if p.%s == nil {
	var f float64
	p.%s = &f
}
*p.%s = tmpFloat64
	`, name, name, name, name, name)
	g.P(code)
}

func (g *generator) emitInt32(f *protogen.Field) {
	name := f.GoName
	code := fmt.Sprintf(`
tmpInt32 = p.Get%s()
imgui.InputInt("%s", &tmpInt32)
if p.%s == nil {
	var i int32
	p.%s = &i
}
*p.%s = tmpInt32
	`, name, name, name, name, name)
	g.P(code)
}

func (g *generator) emitString(f *protogen.Field) {
	name := f.GoName
	code := fmt.Sprintf(`
tmpString = p.Get%s()
imgui.InputText("%s", &tmpString)
if p.%s == nil {
	var s string
	p.%s = &s
}
*p.%s = tmpString
	`, name, name, name, name, name)
	g.P(code)
}

func (g *generator) emitMessage(m *protogen.Message) {

}

func (g *generator) emitFieldRenderingExpression(f *protogen.Field) {
	switch f.Desc.Kind() {
	case protoreflect.FloatKind:
		g.emitFloat32(f)
	case protoreflect.DoubleKind:
		g.emitFloat64(f)
	case protoreflect.Int32Kind:
		g.emitInt32(f)
	case protoreflect.StringKind:
		g.emitString(f)
	case protoreflect.MessageKind:
		g.emitMessage(f.Message)
	}
}

func emitColor(g *protogen.GeneratedFile, m *protogen.Message) {

}

func (g *generator) emitMessageRenderer(m *protogen.Message) {
	g.P(fmt.Sprintf("func Render%s(p *%s) {", m.GoIdent.GoName, g.QualifiedGoIdent(m.GoIdent)))
	for _, f := range m.Fields {
		g.emitFieldRenderingExpression(f)
	}
	g.P("}")
}

type varTypes struct {
	hasFloat32 bool
	hasFloat64 bool
	hasInt32   bool
	hasString  bool
	hasColor   bool
}

func (v *varTypes) gather(m *protogen.Message) {
	for _, f := range m.Fields {
		switch f.Desc.Kind() {
		case protoreflect.FloatKind:
			v.hasFloat32 = true
		case protoreflect.DoubleKind:
			v.hasFloat64 = true
		case protoreflect.Int32Kind:
			v.hasInt32 = true
		case protoreflect.StringKind:
			v.hasString = true
		case protoreflect.MessageKind:
			if f.Desc.FullName() == "game.Color" {
				v.hasColor = true
			} else {
				v.gather(f.Message)
			}
		default:
			log.Fatalf("unsupported field type: %v", f.Desc.Kind())
		}
	}
}

func (g *generator) emitVars(file *protogen.File) {
	v := varTypes{}
	for _, m := range file.Messages {
		v.gather(m)
	}
	g.P("var (")
	if v.hasFloat32 {
		g.P("tmpFloat32 float32")
	}
	if v.hasFloat64 {
		g.P("tmpFloat64 float64")
	}
	if v.hasInt32 {
		g.P("tmpInt32 int32")
	}
	if v.hasString {
		g.P("tmpString string")
	}
	if v.hasColor {
		g.P("tmpColor [3]float32")
	}
	g.P(")")
}

// generateFile generates go source to render a UI for editing the source proto.
func generateFile(gen *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + "_dear_imgui.go"
	g := &generator{gen.NewGeneratedFile(filename, file.GoImportPath)}

	g.P("// Code generated by protoc-gen-imgui. DO NOT EDIT.")
	g.P("package ", file.GoPackageName)

	g.P(`import "github.com/inkyblackness/imgui-go/v4"`)

	g.emitVars(file)

	for _, m := range file.Messages {
		g.emitMessageRenderer(m)
	}
	g.Content()
}
